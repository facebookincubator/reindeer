# Reindeer Care and Feeding

Rust's thriving library ecosystem is built around packages published to
crates.io, each of which describes its metadata and dependency graph using a
Cargo.toml file in a manifest format specified by Cargo, Rust's homegrown build
system.

Reindeer is a tool to programmatically translate a transitive dependency graph
of Cargo.toml manifests into [Buck](https://buck2.build) targets, making it
possible for builds performed by the Buck build system to leverage Cargo
libraries and binaries as dependencies. The translation happens ahead-of-time
when adding or updating Rust dependencies, and produces output that is expected
to be checked into source control. At build time, Cargo is not involved at all;
Buck will directly invoke rustc to compile crates.

Reindeer supports an optional `reindeer vendor` mode which downloads source code
from crates.io and writes it into your repository to be committed to source
control. In vendored mode, no network access to crates.io will happen during
build time; crates are built from the vendored source code. Without `reindeer
vendor`, the Buck targets generated by `reindeer buckify` include steps to
perform the crate download at build time. Vendoring is strongly recommended for
users who know what a "monorepo" is and think they want one.

## Example

See the [first example directory](../examples/01-intro/) as a starting point.
This has:

- Your first-party code in "project" (though of course it can be anywhere and
  everywhere), and
- A [third-party](../examples/01-intro/third-party) directory which is managed
  by Reindeer
- A [`setup.sh`](../examples/01-intro/setup.sh) script to get you bootstrapped

Running `setup.sh` will build Reindeer (using Cargo) and then use it to vendor
the small number of third-party dependencies defined in
[`third-party/Cargo.toml`](../examples/01-intro/third-party/Cargo.toml) and
generate build rules for them in `third-party/BUCK`.

I recommend using this as a starting template for your own project, at least
until you're familiar enough with how everything works to do it yourself.

(There's quite a lot else in there, but we'll get to that.)

## Basic Workflow

You're working away on your code, and you suddenly need to use something from
crates.io. What do you do?

1. Add the specification to `[dependencies]` in `third-party/Cargo.toml`, as you
   would if this were a Cargo project. You can use all the usual options, from a
   simple `foo = "1.2"` to adding features, defining a local name, and so on.
2. Run `reindeer --third-party-dir=third-party vendor`. This will resolve the
   new dependencies (creating or updating `Cargo.lock`), vendor all the new code
   in the `third-party/vendor` directory (also deleting unused code)
3. Run `reindeer --third-party-dir=third-party buckify`. This will analyze the
   Cargo dependencies and (re)generate the BUCK file accordingly. If this
   succeeds silently then there's a good chance that nothing more is needed.
4. Do a test build with `buck build //third-party:new-package` to make sure it
   is basically buildable.

Points to note:

- If any of the packages you're importing (either the ones you're explicitly
  importing or their dependencies) has a `build.rs` build script, you'll need a
  `fixups.toml` file for that package to tell Reindeer how to handle it. See
  [fixups](#Fixups) for details.
- The `vendor` directory is completely under Reindeer's control, and can be
  deleted and regenerated at any time. Do not make any manual local changes in
  there. See [below](#Local-Patches) for details on how to maintain local
  changes.
- Likewise `BUCK` is always completely regenerated by `reindeer buckify`. The
  generated rules can be customized in the
  [reindeer configuration](#Configuring-Reindeer) or in the
  [rule macros](#Buck-Macros).

## Cargo.toml syntax

Reindeer implements the following dependency specification functionality with
equivalent behavior to their meaning in Cargo builds.

**Specifying crate features**

You can enable features or disable default features in the usual Cargo way.

```toml
[dependencies]
serde = { version = 1, features = ["derive", "rc"] }
thiserror = { version = "1", default-features = false }
```

**Git dependencies**

For packages that are not published to crates.io, or that have changes in their
repo not yet published in a crates.io release. For direct dependencies, specify
a git commit using `git` and `rev` in the dependency instead of a `version`.

```toml
[dependencies]
minijail = { git = "https://chromium.googlesource.com/chromiumos/platform/minijail", rev = "fc020fd4672b3340ee706e192d043e12df8c8578" }
```

For substituting a transitive dependencies on a published version to a git
dependency, use `patch`.

```toml
[patch.crates-io]
riscv = { git = "https://github.com/jsgf/riscv.git", rev = "90cfc5f2404e39e085e12845944d5bbbc869c290" }
```

**Platform-specific dependencies**

```toml
[target.'cfg(any(target_arch = "riscv64", target_arch = "riscv64gc"))'.dependencies]
riscv = "0.15"
riscv-rt = "0.16"
```

**Multiple versions of one package**

As with Cargo, direct dependencies are required to be uniquely named. Most of
the time, you will not need to have multiple versions of a particular package
name as direct dependencies. When updating a package, minor API changes can be
accommodated by updating first-party callsites throughout your repo atomically
with the update.

In the event that you need to depend directly on multiple versions of a crate
because an atomic update is infeasible, use Cargo's dependency rename syntax for
giving one or both of the versions a distinct name. The generated Buck target
will receive that name.

```toml
[dependencies]
tokio-01 = { package = "tokio", version = "0.1" }
tokio = "0.2"
```

As with Cargo, transitive dependencies are allowed to have arbitrarily many
versions of the same package name without needing to distinctly name them.

## Custom platforms

Reindeer performs feature resolution independently for each platform that your
build will target. This is implemented in a way that makes crate features
enabled by transitive dependencies of platform-specific dependencies conform
with the feature unification that would occur in a Cargo build.

By default, the set of platforms for which crate features are resolved are the
ones in [src/default_platforms.toml].

[src/default_platforms.toml]: ../src/default_platforms.toml

If you use platform-specific dependencies or platform-specific fixups that
require a different feature resolution than the default platforms, a custom
platform list for use during buckify can be supplied in reindeer.toml and
replaces the default list.

A platform can be specified using a rustc target triple, in which case Reindeer
will run `rustc --print=cfg --target=` during buckify to obtain the platform's
conditional compilation predicates:

```toml
# reindeer.toml

[platform.wasip2]
target = "wasm32-wasip2"
```

Alternatively, a platform can be specified as a list of `target_` conditional
compilation predicates directly. These entries inform evaluation of `cfg(...)`
in platform-specific dependencies and fixups.

```toml
[platform.holodeck]
target_has_atomic = ["8", "16", "32", "64", "128", "256", "512"]
target_pointer_width = ["512"]
target_vendor = ["yoyodyne"]
```

The optional entry `features` in a platform enables that set of features defined
in Cargo.toml. When `features` is not specified, the platform gets the features
`["default"]` by default.

```toml
# reindeer.toml

[platform.thumbv7em-none-eabihf]
target = "thumbv7em-none-eabihf"
features = ["no_std"]

[platform.powerpc]
target = "powerpc-unknown-linux-gnu"
```

```toml
# Cargo.toml

[dependencies]
anyhow = { version = "1", default-features = false }
lazy_static = "1"
panic-abort = { version = "0.3", optional = true }

[features]
default = [
    "anyhow/std",
]
no_std = [
    "lazy_static/spin_no_std",
    "panic-abort",
]
```

By default, Reindeer treats all platforms as not being configured for
cross-compilation. Consider a crate A with a dependency on B, and also a
build-dependency or proc macro dependency on a crate C, where C depends on B and
enables some non-default feature of B. In this situation, by default, A's
dependency on B would see that feature enabled. For no-std platforms or
cross-compilation, this is not what you want. Crates on the no-std target
platform should be able to have build scripts and proc macros that use std on
the execution platform (host platform or RE platform) without causing various
crates' std features to be enabled on the no-std target platform. If you want
accurate feature resolution for cross-compilation to no-std platforms, every
platform must define `execution-platform = true` or `execution-platform =
false`.

```toml
[platform.linux-x86_64]
target = "x86_64-unknown-linux-gnu"
execution-platform = true

[platform.riscv64gc]
target = "riscv64gc-unknown-none-elf"
execution-platform = false
```

Features and optional dependencies enabled by a build script or proc macro on a
platform with `execution-platform = false` will not apply to that platform. They
will be applied instead to every `execution-platform = true` platform.

A Reindeer platform's name (in the `[platform...]` line) becomes a dictionary
key that is indexed using a `select` at build time. If you set up your own
platforms with custom names, you will also need a PACKAGE file that defines how
to recognize those platforms using a `select`.

```starlark
# PACKAGE

load("@prelude//rust:cargo_package.bzl", "DEFAULT_REINDEER_PLATFORMS", "set_reindeer_platforms")

set_reindeer_platforms(
    select({
        "DEFAULT": DEFAULT_REINDEER_PLATFORMS,
        "ovr_config//cpu:arm32-embedded-fpu": "thumbv7em-none-eabihf",
    })
)
```

## Fixups

Fixups are manual package-specific guidance to help Reindeer generate correct
build rules for a crate. They are most commonly needed when the Cargo build does
something that is not characterized by the Cargo manifest, such as the arbitrary
actions of build scripts.

Fixups are defined in `fixups/<package name>/fixups.toml`. The package name is
the name only, not including version.

*Note: after adding or editing a `fixups.toml` you will need to rerun `reindeer
buckify` to incorporate what the fixup says into the package's generated Buck
targets.*

# fixups.toml reference

All top-level keys are optional, except for `buildscript.run` if a package
contains a build.rs.

```ini
extra_srcs = [...]         # list of strings (globs)
omit_srcs = [...]          # list of strings (globs)
precise_srcs = false       # boolean
rustc_flags = [...]        # list of strings
cfgs = [...]               # list of strings
features = [...]           # list of strings
omit_features = [...]      # list of strings
omit_targets = [...]       # list of strings
extra_deps = [...]         # list of strings (Buck targets)
omit_deps = [...]          # list of strings
cargo_env = [...]          # list of strings
overlay = "..."            # string
link_style = "..."         # string
preferred_linkage = "..."  # string
linker_flags = [...]       # list of strings
buildscript.run = true     # boolean
visibility = [...]         # list of strings

[env]                      # map of string to string
ENVNAME = "..."

[rustc_flags_select]       # map of string (Buck constraint target) to list of strings
"DEFAULT" = []
"ovr_config//third-party/python/constraints:3.12" = ["--cfg=Py_3_12"]

[buildscript.build]
extra_deps = [...]         # list of strings (Buck targets)
omit_deps = [...]          # list of strings
link_style = "..."         # string
[buildscript.build.env]    # map of string to string
ENVNAME = "..."

[buildscript.run.env]      # map of string to string
ENVNAME = "..."
```

- **`extra_srcs`** — List of globs of extra sources to be added to the rule
  `srcs` attribute. These are relative to the package manifest dir. Example:
  `extra_srcs = ["README.md", "md_doc/**/*.md"]`

---

- **`omit_srcs`** — List of globs of sources which should be excluded from
  `srcs`. Rarely needed.

---

- **`precise_srcs`** — Set to false to use "\*\*/\*.rs" as the sources, instead
  of trying to parse the module structure from the crate root.

---

- **`rustc_flags`** — List of extra flags to add to the rustc command line.
  Example: `rustc_flags = ["-Ctarget-feature=+avx2,+sse4.2"]`

---

- **`cfgs`** — List of extra `--cfg` options to be passed to rustc. This is
  redundant with `rustc_flags` except that it also informs resolution of the
  crate's conditional dependencies. Example: `cfgs = ["tokio_unstable"]`

---

- **`features`** — List of extra feature flags to enable. Technically redundant
  with _both_ `rustc_flags` and `cfgs`, but convenient. Example: `features =
  ["unstable_wasm"]`

---

- **`omit_features`** — Features to forcibly omit. Example: `omit_features =
  ["proc-macro-crate"]`

---

- **`extra_deps`** — List of extra dependencies to add. Often other C/C++
  libraries if this is a -sys binding package. Example: `extra_deps =
  ["fbsource//third-party/zstd:zstd"]`

---

- **`omit_deps`** — List of dependencies to omit (by package name). Example:
  `omit_deps = ["windows_aarch64_gnullvm"]`

---

- **`cargo_env`** — List of a subset of Cargo's supported environment variables
  to make available to the build. Example: `cargo_env = ["CARGO_PKG_VERSION",
  "CARGO_PKG_AUTHORS"]`

---

- **`overlay`** — A path (relative to fixup dir) of directory which mirrors the
  layout of the package source directory. Any file in the overlay is considered
  a source file which is added to the set of sources passed to the rule. If a
  file overlaps with an existing file, it replaces it. This can be used to add
  or replace source files at a file level.

---

- **`link_style`** — Link style for binaries. Example: `link_style = "shared"`

---

- **`preferred_linkage`** — Link style for libraries. Example:
  `preferred_linkage = "static"`

---

- **`linker_flags`** — Example: `linker_flags = ["/STACK:2097152"]`

---

- **`env`** — Map of extra environment variables to pass at build time.

---

- **`rustc_flags_select`** — Buck constraint-dependent rustc flags.

---

- **`buildscript`** — Specify various ways to handle a build script. See below.

---

- **`visibility`** — Example: `visibility = ["fbsource//some/path/..."]`

---

## Included files

(When not using vendoring _or_ not using `precise_srcs = true` in reindeer.toml,
this section is not relevant to you.)

Some crates include non-Rust sources with `include_str!()` or `include_bytes!()`
(or Rust code in a non-.rs file with `include!()`). In this case you need a
fixups.toml such as:

```toml
extra_srcs = ["readme.txt", "doc/**/*.md"]
```

The paths are relative to the package's manifest dir (that is, where the
package's Cargo.toml file is located), and can be globs or literal paths.

## Environment variables

Some crates use `env!()` to access environment variables that Cargo normally
sets. You can resolve these with a fixups.toml containing:

```
cargo_env = [
    "CARGO_CRATE_NAME",
    "CARGO_MANIFEST_DIR",
    "CARGO_MANIFEST_LINKS",
    "CARGO_PKG_AUTHORS",
    "CARGO_PKG_DESCRIPTION",
    "CARGO_PKG_NAME",
    "CARGO_PKG_REPOSITORY",
    "CARGO_PKG_VERSION",
    "CARGO_PKG_VERSION_MAJOR",
    "CARGO_PKG_VERSION_MINOR",
    "CARGO_PKG_VERSION_PATCH",
    "CARGO_PKG_VERSION_PRE",
]
```

It is recommended to use the minimal set of environment variables that the crate
specifically looks at.

You may also put `cargo_env` in reindeer.toml (as opposed to an individual
crate's fixups.toml) which will apply it to all crates.

## Build and run build.rs build scripts

Build scripts are arbitrary Rust code, and can do weird things in principle and
in practice.

You will be required to examine the build script (usually build.rs located in
the crate root) and assess whether it is reasonable to execute that logic at
build time during a Buck build.

Fortunately most build scripts are fairly tame and involve some combination of:

- shelling out to rustc specified by `env::var_os("RUSTC")`;

- generating cfg flags using `println!("cargo:rustc-cfg=...")`;

- generating sources within `env::var_os("OUT_DIR")`.

When a package has a build script that is irrelevant to building the package
using Buck, use the following fixup to make Reindeer disregard the build script.

```toml
buildscript.run = false
```

To build and run a package's build script, use the following.

```toml
buildscript.run = true
```

In the case of a `buildscript.run = true` fixup, the flow of events looks like
this: Vendoring retrieves the published package from crates.io. The
buckification step creates three buck targets for the new crate. One of the
targets is the expected target representing your crate, for example `name =
"example-0.1.0"`. Then there is a Rust binary target with `name =
"example-0.1.0-build-script-build` for compiling the build script, and one with
`name = "example-0.1.0-build-script-run"` for invoking the build script at build
time to produce generated sources and compiler flags.

You can examine the output produced by a build script by building the following
two subtargets of the `-build-script-run` target. To see generated rustc flags:

```console
buck2 build //third-party/rust:anyhow-1.0.95-build-script-run[rustc_flags] --out=-
```

and to see generated sources:

```console
buck2 build //third-party/rust:coreaudio-sys-0.2.14-build-script-run[out_dir] --show-full-simple-output
```

## C++ dependencies built from source

Reindeer supports build scripts that build and/or link a non-Rust component from
C/C++/asm sources or prebuilt binaries. Use zero or more `[[cxx_library]]` and
`[[prebuilt_cxx_library]]` sections in the fixups.toml to specify these
dependencies.

For example:

```toml
[[cxx_library]]
name = "tree-sitter-javascript"
include_paths = ["src"]
srcs = ["src/parser.c", "src/scanner.c"]
compiler_flags = ["-Wno-unused-parameter", "-Wno-unused-but-set-variable"]
headers = ["src/**/*.h"]
undefined_symbols = true
```

- **`name`** — the name of the library. This is appended onto the general
  package name

---

- **`add_dep`** — if true (default) make this a dependency of the main Rust
  library

---

- **`srcs`** — list of globs of the C/C++/asm sources for the `cxx_library` rule

---

- **`headers`** — list of header files

---

- **`exported_headers`** — headers which are also exported to consumers of this
  rule (relevant if other C/C++ rules depend on it directly)

---

- **`public`** — make the rule have public visibility

---

- **`include_paths`** — list of directories to search for include files,
  relative to the package manifest

---

- **`fixup_include_paths`** — list of include paths relative to the package's
  fixup directory

---

- **`exclude`** — files to exclude from srcs (to compensate for over-broad
  globbing)

---

- **`compiler_flags`** — list of extra flags to pass to the compiler

---

- **`preprocessor_flags`** — list of flags to pass to the preprocessor

---

- **`deps`** — list of extra dependencies, such as other C/C++ libraries

---

## Prebuilt C++ dependencies

`[[prebuilt_cxx_library]]` is used when the package comes with prebuilt
libraries which need to be linked with the final executable. Currently only
static libraries are supported and set of parameters is fairly minimal.

```toml
[[prebuilt_cxx_library]]
name = "windows.lib"
static_libs = ["lib/windows.lib"]
```

- **`name`** — the name of the library. This is appended onto the general
  package name and suffixed with static library filename.

---

- **`static_libs`** — list of globs of the prebuilt static libraries. For each
  file  `prebuilt_cxx_library` rule will be created

---

- **`add_dep`** — if true (default) make this a dependency of the main Rust
  library

---

- **`public`** — make the rule have public visibility

---

## Platform-specific fixups

By default, fixups are applied to all platforms. It's also possible to define
fixups which apply to a subset of platforms only:

```toml
['cfg(all(target_os = "linux", target_arch = "x86_64"))']
cfgs = ["use_libunwind"]
extra_deps = ["fbsource//third-party/libunwind:unwind-ptrace"]
```

Any TOML section starting with "cfg(" is a platform-specific fixup.

Such sections take the same parameters as the top-level of the file, except
they're only applied to platforms for which the `cfg` predicate evaluates to
true according to the Reindeer platform's target information.

In the case of the example above, this fixup would apply to all x86\_64 Linux
platforms, including platform010 (datacenter Linux) and centos-x86\_64 (Linux
with dependencies from Antlir CentOS toolchains), but would not apply to
Windows, macOS, AArch64 Linux, Android, iOS, etc.

A platform-spefic C++ library would look like this:

```toml
buildscript.run = false

[['cfg(target_os = "linux")'.cxx_library]]
name = "sysinfo-linux"
srcs = ["c/linux.c"]
headers = ["c/*.h"]
```

## Version-specific fixups

Multiple versions of the same Rust crate can co-exist in a Cargo dependency
graph. The same Reindeer fixup normally applies to all versions of the crate
that has the matching crate name.

To write a fixup that applies to a subset of crate versions, follow the same
syntax as a "platform-specific fixup" from above but using `version` as a cfg
predicate.

```toml
['cfg(version = ">=0.18")']
extra_srcs = ["src/tmux_cc/tmux.pest"]
```
